---
title: "Simulation from species 1 life history"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Simulation from species 1 life history}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message=FALSE}
library(tidyverse)
library(CKMRpop)
```


For this first example, we use the hypothetical life history of species 1.
First we have to set spip up to run with that life history.

## Setting the spip parameters 

### Basic life history parameters 

These parameters are included in the package in the variable `species_1_life_history`.
It is named list of parameters to send to spip.  The list names are the names of the
spip options.  It looks like this:
```{r}
species_1_life_history
```

We want to add instructions to those, telling spip how long to run the simulation,
and what the initial census sizes should be.  

So, first, we copy `species_1_life_history` to a new variable, `SPD`:
```{r}
SPD <- species_1_life_history
```
Now, we can add things to SPD.

###  Setting Initial Census, New Fish per Year, and Length of Simulation

The number of new fish added each year is called the "cohort-size".  Once we know
that, we can figure out what the stable age distribution would be given the survival
rates, and we can use that as our starting point.  There is a function
in the package that helps with that:
```{r}
# before we tell spip what the cohort sizes are, we need to 
# tell it how long we will be running the simulation
SPD$`number-of-years` <- 100  # run the sim forward for 100 years

# this is our cohort size
cohort_size <- 300

# Do some matrix algebra to compute starting values from the
# stable age distribution:
L <- leslie_from_spip(SPD, cohort_size)

# then we add those to the spip parameters
SPD$`initial-males` <- floor(L$stable_age_distro_fem)
SPD$`initial-females` <- floor(L$stable_age_distro_male)

# tell spip to use the cohort size
SPD$`cohort-size` <- paste("const", cohort_size, collapse = " ")


```


### Specifying the fraction of sampled fish, and in different years

Spip let's you specify what fraction of fish of different ages should be
sampled in different years.  Here we do something simple, and instruct
spip to sample 1% of the fish every year from 50 to 75.
```{r}
samp_frac <- 0.01
samp_start_year <- 50
samp_stop_year <- 75
SPD$`discard-all` <- 0
SPD$`gtyp-ppn-fem-pre` <- paste(
  samp_start_year, "-", samp_stop_year, " ", 
  samp_frac, " ", samp_frac, " ", samp_frac, " ",
  paste(rep(0, SPD$`max-age` - 3), collapse = " "),
  sep = ""
)
SPD$`gtyp-ppn-male-pre` <- SPD$`gtyp-ppn-fem-pre`
```

## Running spip and slurping up the results

There is a function that does all this for you.  It runs spip in
a temporary directory.  After running spip, it also processes the output
with a few shell scripts.  The function returns the path to the temporary
directory.  You will need that to slurp all the results back in.
```{r}
set.seed(5)
spip_dir <- run_spip(pars = SPD)

# now read that in and find relatives within the grandparental range
slurped <- slurp_spip(spip_dir, 2)
```

## Some functions to summarize the runs

Although during massive production simulations, you might not go back to every run
and summarize it to see what it looks like, when you are parameterizing demographic
simulations you will want to be able to quickly look at observed demographic rates
and things.  There are a few functions in CKMRpop that make this quick and easy to do.

### Plot the age-specific census sizes over time

This is just a convenience function to make a pretty plot so you can check to
see what the population demographics look like:
```{r, fig.width = 7, fig.height = 5.5}
ggplot_census_by_year_age_sex(slurped$census_prekill)
```
This shows that the function `leslie_from_spip()` does a good job of finding the
initial population numbers that accord with the stable age distibution.

### Assess the observed survival rates

We can compute the survival rates like this:
```{r}
surv_rates <- summarize_survival_from_census(slurped$census_prekill)
```

That returns a list.  One part of the list is a tibble with observed survival fractions.
The first 40 rows look like this:
```{r}
surv_rates$survival_tibble %>%
  slice(1:40)
```
The second part of the list holds a plot with histograms of age-specific,
observed survival rates across all years.  The blue line is the mean over
all years.
```{r, fig.width = 9, fig.height=7.5, out.height=600, out.width=700}
surv_rates$plot_histos_by_age_and_sex
```

To compare these values to the parameter values for the simulation, you must
pass those to the function:
```{r, fig.width = 9, fig.height=7.5, out.height=600, out.width=700}
surv_rates2 <- summarize_survival_from_census(
  census = slurped$census_prekill,
  fem_surv_probs = SPD$`fem-surv-probs`, 
  male_surv_probs = SPD$`male-surv-probs`
)

# print the plot
surv_rates2$plot_histos_by_age_and_sex
```

Here, the red dashed line is the value chosen as the parameter for
the simulations. The means are particularly different for the older
age classes, which makes sense because there the total number of
individuals in each of those year classes is smaller.

## The distribution of offspring and mate number

It makes sense to check that your simulation is delivering a reasonable distribution
of offspring per year.  This is the number of offspring that survive to just before the
first prekill census.  Keep in mind that, for super high-fecundity speces, we won't model
every single larva, we just don't start "keeping track of them" until they reach a stage
that is recognizable in some way. 

We make this summary from the pedigree information. 
In order to get the number of adults that were present, but did not produce any offspring,
we also need to pass in the postkill census information.  Also, to get limetime
reproductive output, we need to know how old individuals were when they died, so 
we also pass in the information about deaths.  

To make all the summaries, we do:
```{r}
offs_and_mates <- summarize_offspring_and_mate_numbers(
  census_postkill = slurped$census_postkill,
  pedigree = slurped$pedigree,
  deaths = slurped$deaths, lifetime_hexbin_width = c(1, 2)
)
```

Note that we are setting the lifetime reproductive output hexbin width to be suitable
for this example.  

The function above returns a list of plots, as follows:

### Age and sex specific number of offspring

```{r, fig.width = 7, fig.height = 5.5}
offs_and_mates$plot_age_specific_number_of_offspring
```

Especially when dealing with viviparous species (like sharks and mammals) it is
worth checking this to make sure that there aren't some females having far too many
offspring.


### Lifetime reproductive output as a function of age at death

Especially with long-lived organisms, it can be instructive to see how lifetime
reproductive output varies with age at death.

```{r, fig.height = 6, fig.width = 7}
offs_and_mates$plot_lifetime_output_vs_age_at_death
```

Yep, many individuals have no offspring, and you have more kids if you live longer.


### Fractional contribution of each age class to the year's offspring

Out of all the offspring born each year, we can tabulate the fraction that
were born to males (or females) of each age.  This summary shows a histogram
of those values.  The represent the distribution of the fractional contribution
of each age group each year.
```{r, fig.width=7, fig.height=7}
offs_and_mates$plot_fraction_of_offspring_from_each_age_class
```

The blue vertical lines show the means over all years.


## Compiling the related pairs from the samples

From the samples that slurped up from the spip output we 
compile all the related pairs that we found in there with a single
function.  It is important to note that this finds all the related pairs
that share ancestors back within `num_generations` generations. Recall, that
we ran `slurp_spip()` with `num_generations = 2` which means that we
check for matching ancestors up to an including the grandparents of the sample.
```{r}
crel <- compile_related_pairs(slurped$samples)
```
The result that comes has a single row in each pair. The individuals appear in
each pair such that the first name comes before the second name, alphabetically,
in each pair.  There is information in list columns about the year(s) that each
member of the pair was sampled in and also years in which they were born, and also
the indices of the populations they were sampled from.  (Knowing the population
will become useful when/if we start simulating multiple populations connected
by gene flow).  Here we show the first 40 pairs in the samples:
```{r}
crel %>%
  slice(1:40)
```
The crucial piece of information for learning how each pair is related is in
the `anc_match_matix` column.  This stands for "ancestry match matrix."  It holds a TRUE
for each shared ancestor in the two individual's ancestry (out to `num_generations`).
If this seems obtuse, it should become more understandable when we look at some figures.

Here, we count up the number of pairs in all the possible relationship types:
```{r}
relat_counts <- count_and_plot_ancestry_matrices(crel)
```

The first component of the return list is a tibble of the relationship counts:
```{r}
relat_counts$anc_mat_counts
```
And the second part holds a series of pages/plots showing all the different
ancestry matrices seen. Here are the first 30:
```{r, fig.width=7, fig.height=7}
relat_counts$plots[[1]]
```

And here are the remaining 15 relationship types:
```{r, fig.width=7, fig.height=7}
relat_counts$plots[[2]]
```

If you look at these long enough you will start to see that along the first
row, from left to right we have: 

- 001 = half cousin
- 002 = paternal half-sib
- 003 = half uncle
- 004 = half cousin
- 005 = maternal half-sib

The second and third rows are all half cousins and half-uncle
or half-aunt relationships. In the fourth row, when we get to
019 and 020, we are seeing some full cousins.  022 is a full-aunt
relationship.

I am going to work on some code to collapse these groups according to
the "dominant" or closest relationship in each, but have pursued this
approach of visualizing matrices in order to be able to tabulate and
understand all the different sorts of bizarre relationships we might
encounter.


